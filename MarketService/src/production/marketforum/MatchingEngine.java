package production.marketforum;

import java.util.HashMap;
import java.util.LinkedList;
import java.util.Map;
import java.util.PriorityQueue;
import java.util.Set;

import javax.enterprise.context.ApplicationScoped;
import javax.jms.Connection;
import javax.jms.ConnectionFactory;
import javax.jms.JMSException;
import javax.jms.MessageProducer;
import javax.jms.Session;

import org.jboss.logging.Logger;
import production.entity.*;
import production.enums.PostingType;
import production.enums.PostOutcome;
import production.exceptions.MarketPostingTypeException;

/**
 * Market is the forum in which buyers are matched with sellers. So we must have
 * two hashmaps, one for offers(from sellers) and one for requests(from buyers)
 * 
 * @author e588318
 */

@ApplicationScoped
public class MatchingEngine {
	private Logger log = Logger.getLogger(MatchingEngine.class);

	private Map<String, PriorityQueue<Post>> offers;
	private Map<String, PriorityQueue<Post>> requests;

	public MatchingEngine() {
		// DataStructure initialization
		this.offers = new HashMap<String, PriorityQueue<Post>>();
		this.requests = new HashMap<String, PriorityQueue<Post>>();
	}

	public LinkedList<MarketResolutionReport> postListing(Post incomingPost){
		Post post = incomingPost.deepCopy();
		if(post.getPostingType() == PostingType.OFFER){
			//does the market contain a complementaryListing for this symbol?
					//if yes, attempt to resolve to post
					if(this.requests.containsKey(post.getSymbol()))
						return this.resolvePost(post);
					//if no, create a listing for this post
					else{
						LinkedList<MarketResolutionReport> reports = new LinkedList<>();
						reports.add(this.handleUnresolvedPost(post));
						return reports;
					}
		}
		else {
			//does the market contain a complementary listing for thissymbol?
			//if yes, attempt to resolve to post
			if(this.offers.containsKey(post.getSymbol()))
				return this.resolvePost(post);
				//if no, create a listing for this post
			else{
				LinkedList<MarketResolutionReport> reports = new LinkedList<>();
				reports.add(this.handleUnresolvedPost(post));
				return reports;
			}
		}
	}
	
	

	/**
	 * Resolve post is the market resolution algorithm. The method determines
	 * the posting type of the post object, looks up the complimentary listing
	 * for the post’s symbol, then attempts to fill the volume of the post from
	 * the available orders from the complimentary listing, generating market
	 * resolution reports as it does so. The algorithm will generate a new
	 * priority queue containing the incoming post object if the market cannot
	 * fulfill the incoming post’s demand. The method returns a list of market
	 * resolution reports containing sales generated by the resolution algorithm
	 * param post
	 * 
	 * @return throws Exception
	 */
	private LinkedList<MarketResolutionReport> resolvePost(Post post) {
		PriorityQueue<Post> pertinentListing;
		LinkedList<MarketResolutionReport> reports = new LinkedList<>();
		// get the complimentary listing for the post (if the post is anoffer,
		// get the requests and vice versa
		if (post.getPostingType() == PostingType.OFFER)
			pertinentListing = this.requests.get(post.getSymbol());
		else
			pertinentListing = this.offers.get(post.getSymbol());

		// Check to see if the PertinentListing contains an applicableposting
		// and the offer still contains unfulfilled volume
		while (this.complimentaryListingContainsApplicablePostings(pertinentListing, post) && post.getVolume() > 0) { 
			// poll the	listing to obtain the best listing price
			Post bestListing = pertinentListing.poll();
			// resolve the listings, generating a report
			MarketResolutionReport report = this.resolveListings(post, bestListing);
			// Apply the changes in the resolution report to our current
			// post/post objects:
			this.subtractReportVolumeFromPosts(report, post, bestListing);
			// if the pertinent listing has remaining volume, reinsert
			// it into the appropriate queue
			if (bestListing.getVolume() > 0) {
				pertinentListing.add(bestListing);
			}
			// add the report to the report list
			reports.add(report);
		}
		// Does the post still contain unfilled volume?
		if (post.getVolume() > 0) {
			reports.add(this.handleUnresolvedPost(post));
		}
		// return the list of reports
		return reports;
	}
	
	public String generateReport() {
		String status = "";
		for(PriorityQueue<Post> queue : this.offers.values()) {
			if(!queue.isEmpty()) {
				status += "Offer Listing " + queue.peek().getSymbol() + " of size : " + queue.size() + "\n";
			}	 
		}
		for(PriorityQueue<Post> queue: this.requests.values())
		{
			if(!queue.isEmpty()) {
				status += "Request Listing " + queue.peek().getSymbol() + " of size : " + queue.size() + "\n";
			}	 
		}
		return status;
	}

	private boolean complimentaryListingContainsApplicablePostings(PriorityQueue<Post> listing, Post post)
	{
		//first check for a null pointer exception, we may be receiving an empty listing
		//this will be the case when the matching engine resolves all of the postings on
		//the pertinent listing, and then checks to see if the listing contains another
		//post with the peek() method, throwing a null pointer exception.
		try{
			//if we are dealing with an offer posting,
			if(post.getPostingType() == PostingType.OFFER)
			{ 	//then does the listing (of requests) contain postings
				//which are greater than or equal to the price of the posting?
				if(listing.peek().getPrice() >= post.getPrice())
					return true;
				else
					return false;
			}
			else{//otherwise the post is a request, and check if the best offer price
				//is LESS than or equal to the post’s price
				if(listing.peek().getPrice() <= post.getPrice())
					return true;
				else
					return false;
			}
		}
		catch(NullPointerException e){
			return false;
		}
	}

	/**
	 * The applyReportToListingObjects accepts a report object, and two post
	 * objects describing the request and offer posts The method subtracts the
	 * report’s volume field from both the request and offer objects Volume
	 * field
	 */
	private void subtractReportVolumeFromPosts(MarketResolutionReport report, Post postObject1, Post postObject2) {
		postObject1.setVolume(postObject1.getVolume() - report.getVolume());
		postObject2.setVolume(postObject2.getVolume() - report.getVolume());
	}

	/**
	 * ResolveListings accepts a request and an offer, and builds a
	 * marketResolutionReport describing the parameter of the sale, and returns
	 * the report param request param offer return
	 */
	private MarketResolutionReport resolveListings(Post firstPost, Post secondPost) {
		// handle incoming ambiguity: Which post is the offer and which post
		// isthe request
		Post offer;
		Post request;
		if (firstPost.getPostingType() == PostingType.OFFER) {
			offer = firstPost;
			request = secondPost;
		} else {
			offer = secondPost;
			request = firstPost;
		}
		// Two possible use cases here: the offer requires more volume than
		// therequest object
		// possesses, or vice versa.
		MarketResolutionReport report = new MarketResolutionReport();
		report.setBuyerIdentifier(request.getUserIdentifier());
		report.setSellerIdentifier(offer.getUserIdentifier());
		report.setSymbol(offer.getSymbol());
		// The price will be the seller’s price
		report.setPrice(offer.getPrice());
		// Determine the sale volume
		if (offer.getVolume() > request.getVolume()) {
			// the offer will have leftover volume, the request will have 0
			// volume,
			// therefore the sale volume will be equal to the request’s current
			// volume.
			report.setVolume(request.getVolume());
		} else {// otherwise the offer volume is less than or equal to the
				// request
				// The offer will be completely filled by the request, so set
				// the sale volume to
				// equal the offer volume
			report.setVolume(offer.getVolume());
		}
		return ReportingUtility.loadTwoPostsToReport(report, offer, request);
	}

	private MarketResolutionReport handleUnresolvedPost(Post post) {
		MarketResolutionReport report = new MarketResolutionReport();
		report.setPostOutcome(PostOutcome.NOT_COMPLETED);
		// Is this an offer or a request?
		if (post.getPostingType() == PostingType.OFFER) {
			// Does a listing of this type currently exist in the offers field
			// for the post’s symbol?
			if (this.offers.containsKey(post.getSymbol())) {
				// add it to that order book
				this.offers.get(post.getSymbol()).add(post);
			} else { // otherwise generate a new priority queue, insert the
						// post to that queue, and insert the queue to the
						// offers field mapped
						// to the post’s symbol
				PriorityQueue<Post> newListing = new PriorityQueue<>();
				newListing.add(post);
				this.offers.put(post.getSymbol(), newListing);
			}
		}
		// else it is request:
		else {
			// Do the request listings contain a queue for this symbol?
			// if so, add it to that listing
			if (this.requests.containsKey(post.getSymbol())) {
				this.requests.get(post.getSymbol()).add(post);
			} else {// otherwise generate a new queue containing this post
					// and add it to the this.requests field
				PriorityQueue<Post> newListing = new PriorityQueue<>();
				newListing.add(post);
				this.requests.put(post.getSymbol(), newListing);
			}
		}
		return ReportingUtility.loadSinglePostToIncompleteReport(post);
	}
	
	

	private static class ReportingUtility {
		
		protected static MarketResolutionReport loadSinglePostToIncompleteReport(Post post){
			MarketResolutionReport report = new MarketResolutionReport();
			if(post.getPostingType() == PostingType.OFFER)
			{//If we are receiving an offer, then load the information to theseller field
				//of the report
				report.setSellerIdentifier(post.getUserIdentifier());
				report.setSellerDate(post.getDate());
				report.setPostOutcome(PostOutcome.NOT_COMPLETED);
				return report;
			}
			else{
				report.setBuyerIdentifier(post.getUserIdentifier());
				report.setBuyerDate(post.getDate());
				report.setPostOutcome(PostOutcome.NOT_COMPLETED);
				return report;
			}
		}
			
		protected static MarketResolutionReport loadTwoPostsToReport(MarketResolutionReport report, Post offer, Post request)
			{
				report.setBuyerIdentifier(request.getUserIdentifier());
				report.setBuyerDate(request.getDate());
				report.setPostOutcome(PostOutcome.COMPLETED);
				//Seller’s rule, therefore we set the report’s price to the offer’s listed price
				report.setPrice(offer.getPrice());
				report.setSellerIdentifier(offer.getUserIdentifier());
				report.setSellerDate(offer.getDate());
				//volume is set when the two postings are resolved, therefore we don’t have to worry wout setting it here,
				//and we can just return the report
						return report;

			}
	}
}